/**
 * JAM Framework v2 - JDAT Integration Bridge
 * 
 * Integrates JDAT audio streaming with JAM Framework v2 UDP transport
 * and PNBTR prediction for seamless audio transmission.
 */

#pragma once

#include "jam_core.h"
#include "jam_toast.h"
#include "multithreaded_transport.h"
#include <memory>
#include <functional>
#include <string>

// Forward declarations for JDAT
namespace jdat {
    class JELLIEEncoder;
    class JELLIEDecoder; 
    struct JDATMessage;
    enum class SampleRate;
    enum class AudioQuality;
}

namespace jam {

/**
 * JDAT-JAM Integration Configuration
 */
struct JDATConfig {
    // Audio settings
    jdat::SampleRate sample_rate;
    jdat::AudioQuality quality;
    uint32_t frame_size_samples = 480;  // 10ms at 48kHz
    uint32_t buffer_size_ms = 20;
    
    // JAM Framework settings
    std::string session_name = "JDAT_Session";
    std::string multicast_address = "239.255.77.88"; // Different from TOAST
    uint16_t udp_port = 7788;
    
    // PNBTR settings
    bool enable_audio_prediction = true;
    bool enable_gpu_native = true;
    uint8_t redundancy_level = 2;
    
    // Multi-threading
    bool enable_multithreaded_transport = true;
    int send_threads = 2;
    int recv_threads = 2;
};

/**
 * JDAT Audio Frame for JAM Framework v2 Transport
 */
struct JDATAudioFrame {
    uint64_t timestamp_us;
    uint32_t sample_rate;
    uint16_t channels;
    uint16_t bits_per_sample;
    std::vector<float> samples;
    uint32_t sequence_number;
    uint8_t stream_id;
    bool is_prediction;  // Generated by PNBTR
};

/**
 * JAM-JDAT Bridge: Connects JDAT audio streaming to JAM Framework v2
 */
class JDATBridge {
public:
    // Callback function types
    using AudioInputCallback = std::function<void(const float* samples, int numSamples, uint32_t sampleRate)>;
    using AudioOutputCallback = std::function<void(const JDATAudioFrame& frame)>;
    using StatusCallback = std::function<void(const std::string& status, bool connected)>;
    using ErrorCallback = std::function<void(const std::string& error)>;
    
    JDATBridge(const JDATConfig& config);
    ~JDATBridge();
    
    // === Lifecycle Management ===
    
    /**
     * Initialize JDAT components and JAM Framework v2 transport
     */
    bool initialize();
    
    /**
     * Start audio streaming and network transport
     */
    bool start();
    
    /**
     * Stop all operations
     */
    void stop();
    
    /**
     * Check if bridge is active
     */
    bool isActive() const { return is_active_; }
    
    // === Audio Input/Output ===
    
    /**
     * Process input audio samples for transmission
     * Called by audio input system (e.g., microphone)
     */
    void processInputAudio(const float* samples, int numSamples, uint32_t sampleRate);
    
    /**
     * Get output audio frame for playback
     * Called by audio output system (e.g., speakers)
     */
    bool getOutputAudio(JDATAudioFrame& frame);
    
    // === Callback Registration ===
    
    void setAudioInputCallback(AudioInputCallback callback) { audio_input_callback_ = callback; }
    void setAudioOutputCallback(AudioOutputCallback callback) { audio_output_callback_ = callback; }
    void setStatusCallback(StatusCallback callback) { status_callback_ = callback; }
    void setErrorCallback(ErrorCallback callback) { error_callback_ = callback; }
    
    // === Configuration ===
    
    /**
     * Enable/disable PNBTR audio prediction
     */
    void enableAudioPrediction(bool enable);
    
    /**
     * Enable/disable GPU NATIVE processing
     */
    void enableGPUNative(bool enable);
    
    /**
     * Set audio quality level
     */
    void setAudioQuality(jdat::AudioQuality quality);
    
    /**
     * Get current performance metrics
     */
    struct PerformanceMetrics {
        double latency_ms = 0.0;
        double throughput_mbps = 0.0;
        double packet_loss_rate = 0.0;
        int active_streams = 0;
        double audio_quality_score = 0.0;
        int buffer_underruns = 0;
        int buffer_overruns = 0;
    };
    
    PerformanceMetrics getPerformanceMetrics() const;
    
    // === Network Status ===
    
    int getActiveStreamCount() const;
    double getCurrentLatency() const;
    bool isNetworkHealthy() const;

private:
    JDATConfig config_;
    
    // JDAT components
    std::unique_ptr<jdat::JELLIEEncoder> encoder_;
    std::unique_ptr<jdat::JELLIEDecoder> decoder_;
    
    // JAM Framework v2 components
    std::unique_ptr<MultiThreadedUDPTransport> transport_;
    std::unique_ptr<TOASTv2Protocol> toast_protocol_;
    std::unique_ptr<ComputePipeline> gpu_pipeline_;
    
    // State management
    std::atomic<bool> is_active_{false};
    std::atomic<bool> is_initialized_{false};
    uint32_t session_id_ = 0;
    
    // Audio buffers
    std::vector<JDATAudioFrame> output_buffer_;
    std::mutex output_buffer_mutex_;
    
    // Performance tracking
    mutable std::mutex metrics_mutex_;
    PerformanceMetrics current_metrics_;
    
    // Callbacks
    AudioInputCallback audio_input_callback_;
    AudioOutputCallback audio_output_callback_;
    StatusCallback status_callback_;
    ErrorCallback error_callback_;
    
    // Internal methods
    void handleJDATMessage(const jdat::JDATMessage& message);
    void handleNetworkData(const std::vector<uint8_t>& data);
    void processAudioPrediction(JDATAudioFrame& frame);
    void updatePerformanceMetrics();
    void notifyStatus(const std::string& status, bool connected);
    void notifyError(const std::string& error);
    
    // JDAT-TOAST conversion
    TOASTFrame convertJDATToTOAST(const jdat::JDATMessage& jdat_message);
    jdat::JDATMessage convertTOASTToJDAT(const TOASTFrame& toast_frame);
    
    // Audio processing
    void applyAudioPrediction(std::vector<float>& samples);
    bool validateAudioFrame(const JDATAudioFrame& frame);
};

/**
 * JDAT Integration for TOASTer Application
 * Simplified interface for integrating JDAT audio into TOASTer
 */
class TOASTerJDATIntegration {
public:
    TOASTerJDATIntegration();
    ~TOASTerJDATIntegration();
    
    // Simple interface for TOASTer
    bool initializeAudioStreaming(const std::string& session_name = "TOASTer_Audio");
    bool startAudioTransmission();
    void stopAudioTransmission();
    
    // Audio I/O
    void sendAudioData(const float* samples, int numSamples, int sampleRate);
    bool receiveAudioData(float* samples, int maxSamples, int& actualSamples, int& sampleRate);
    
    // Status
    bool isAudioConnected() const;
    int getActiveAudioPeers() const;
    double getAudioLatency() const;
    
    // Callbacks for TOASTer UI
    using AudioStatusCallback = std::function<void(const std::string& status, bool connected, int peers)>;
    void setAudioStatusCallback(AudioStatusCallback callback) { audio_status_callback_ = callback; }

private:
    std::unique_ptr<JDATBridge> jdat_bridge_;
    JDATConfig default_config_;
    AudioStatusCallback audio_status_callback_;
    
    void onJDATStatus(const std::string& status, bool connected);
    void onJDATAudioOutput(const JDATAudioFrame& frame);
};

} // namespace jam
