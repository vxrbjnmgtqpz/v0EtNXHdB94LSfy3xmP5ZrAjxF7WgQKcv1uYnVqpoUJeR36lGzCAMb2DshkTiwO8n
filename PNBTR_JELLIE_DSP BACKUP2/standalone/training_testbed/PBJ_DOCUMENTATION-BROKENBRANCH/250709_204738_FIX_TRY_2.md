Analysis of Non-Functional Transport Bar
Buttons Not Wired to Audio Engine (No Session Callback)
The transport bar’s Play, Stop, Pause, and Record buttons are not invoking any audio session or DSP engine actions when clicked. In the ProfessionalTransportController code, these buttons are created and displayed, but their callbacks never call into the audio engine (e.g. no call to a “play” or “record” function on the DSP side). In other words, the UI buttons toggle or change their appearance but do not trigger the PNBTRTrainer or any engine method. According to the design, the Play button should start audio processing, Stop should halt it, Pause should suspend it, and Record should enable recording mode – but none of these behaviors occur because the button onClick handlers are either absent or contain no calls to the engine. This means clicking “Play” or “Record” currently does nothing to the underlying audio session. The root cause is that the transport controller UI isn’t connected to the engine’s transport controls at all.
No Reference to PNBTRTrainer in Transport Controller
Critically, the ProfessionalTransportController is never given a pointer or reference to the PNBTRTrainer (the audio/DSP session). The transport controller has no way to call engine functions because it doesn’t know about the session object. We find that its constructor and members do not store any PNBTRTrainer reference, nor does it register any callback with a session singleton or global. This disconnect explains why the buttons do nothing – the UI lacks access to the engine. Essentially, the transport bar was implemented in isolation, without hooking into the audio playback/record system. The code treats ProfessionalTransportController purely as a GUI component (“main transport interface”) while the engine lives separately in the DSP module. Since the controller wasn’t wired up through a reference or callback, pressing the buttons never calls trainer->start() or any equivalent function. This is a design oversight: the transport controller should either be constructed with a session reference or obtain one, but in the current code it does not, leaving the play/record controls non-operative.
Broken State Synchronization Between UI and DSP
Because of the missing linkage, transport state changes in the UI don’t propagate to the DSP engine (and vice versa). For example, the Record button may visually toggle (if it’s set as a toggle button), but since no recording routine is invoked, the application never actually enters “recording mode.” The Pause button similarly has no effect on the audio processing state – there is no pause functionality called on the engine, so any internal pause/resume state remains unchanged. In a working design, these UI controls would synchronize with the session state (e.g. enabling recording mode in the engine, pausing the audio callback, etc.), but here that synchronization is absent. The expected behavior was that Record would enable recording and Pause would pause processing while maintaining state. In the current implementation, however, toggling those buttons does nothing to the underlying PNBTRTrainer. Likewise, indicators like the session timer or play button state never update based on actual playback because the engine’s state changes (if any) aren’t communicated back to the UI. This confirms a complete breakdown in state sync: the transport UI and the audio engine are operating in isolation.
No Transport-Engine Integration in MainComponent
The MainComponent (the application’s main UI container) does not bridge the transport controller with the audio engine, which it ideally should. The codebase identifies MainComponent.cpp as responsible for “transport control wiring and callbacks”, but currently there is no such wiring present. In MainComponent, the ProfessionalTransportController is added to the interface, yet no code in MainComponent forwards transport commands to the PNBTRTrainer. For instance, we find no call like trainer.start() or trainer.stop() in response to the Play/Stop buttons. There’s also no observer pattern or listener set up to connect the UI and engine. This suggests that when the duplicate transport buttons were removed from ControlsRow (the network controls panel), the developers intended to rely on the ProfessionalTransportController for transport, but they never completed the hookup in MainComponent. The result is that the transport bar exists in the UI with no effect on the running session. In summary, the MainComponent fails to act as the middleman between the UI and DSP – a crucial piece of glue logic is missing, leaving the transport buttons orphaned from the audio engine.
Fix: Connecting the Transport Bar to the DSP Engine
To restore functionality, we need to modify the critical components so that the transport bar UI drives the audio engine’s transport controls. The key files involved will be the transport controller and the main component (and possibly the trainer). Below are the specific patch steps:
Pass a Session Reference to the Transport Controller: Ensure that ProfessionalTransportController knows about the PNBTRTrainer (or the relevant session interface). For example, add a pointer or reference member in ProfessionalTransportController that points to the active PNBTRTrainer. You can achieve this by passing the trainer object into the transport controller’s constructor (e.g. ProfessionalTransportController(PNBTRTrainer& trainer) or storing a pointer). This allows the transport UI to call engine methods directly. Be mindful of construction order – the trainer should be created before the transport controller so that a valid reference is passed (if they are members of MainComponent, declare the trainer member above the transport controller so it’s constructed first). If modifying the constructor is undesirable, you can alternatively provide a setter like transportController.setTrainer(trainer) right after constructing it.
Wire Play/Stop/Pause/Record to PNBTRTrainer: Implement the onClick callbacks for each transport button to invoke the corresponding session controls. For instance, in ProfessionalTransportController.cpp, set up:
Play button onClick to call something like trainer.start() (or trainer.play() if such a method exists) to begin audio processing.
Stop button to call trainer.stop() and reset the transport state.
Pause button to call a pause method (if available) or alternatively call trainer.stop() but preserve the current playhead state so it can resume (you may need to implement a pause/resume in the trainer if not already present).
Record button to enable recording mode in the engine – e.g. call a method on the trainer such as trainer.beginRecording() or set a flag like trainer.setRecording(true). Ensure that if the Record button is a toggle, its state (on/off) is used to start or stop recording accordingly. By explicitly triggering the engine’s recording routine, the UI’s Record toggle will correspond to actual recording behavior in the DSP.
Update MainComponent to Forward Transport Commands: In MainComponent.cpp, after constructing the transport controller (and possibly after creating the audio trainer), connect the two. If you passed the trainer into the transport controller, the onClick lambdas inside it can call the trainer directly. Otherwise, you can connect callbacks in MainComponent: for example, using lambda captures or std::function, assign transportController.playButton.onClick = [this] { trainer.start(); } etc. MainComponent should also handle any global state updates – for instance, resetting other UI elements when Stop is pressed (if needed). The goal is to ensure the UI actions invoke the exact engine functions that start/stop audio processing as intended.
Synchronize State Back to UI (if needed): To fully close the loop, consider updating the UI based on engine state changes. For example, once playback actually starts, you might want to change the Play button to a “pressed” or disabled state until stopped, or start a session timer display. This could be done by having the trainer call a callback or using a timer in the UI to poll the engine state. While not strictly necessary for basic functionality, it improves feedback. For now, focus on at least one-way control: the UI instructs the engine. The expected behaviors are defined (play starts DSP, stop resets it, etc.), so implementing those calls will achieve the core functionality.
Verify Construction and Lifetime: After making these changes, test that the application still initializes properly. If the transport controller is constructed with a reference to the trainer, verify that the trainer is initialized beforehand (adjust member initialization order in MainComponent as needed to avoid a null or invalid reference). Also ensure that destroying the MainComponent will clean up the transport and trainer safely (if using raw pointers for the trainer reference, you might use a reference or observe lifetime to avoid dangling pointers).
By applying these modifications, the transport bar will become functional. The Play, Stop, Pause, and Record buttons will directly control the PNBTRTrainer session, fulfilling their intended roles. In effect, clicking Play will start the audio processing, Stop will halt it, Pause will suspend/resume it, and Record will engage recording mode – making the transport bar an active controller of the DSP engine as originally designed.

Sources
