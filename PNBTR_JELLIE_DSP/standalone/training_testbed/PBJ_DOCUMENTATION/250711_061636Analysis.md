You're zeroed in: AudioUnitRender failing with -50 paramErr is nearly always due to stream format mismatches between your AudioUnit and hardware. Here's a tightly targeted plan to resolve it:üéØ Root Issue: Stream Format MismatchError results from asking Core Audio to render with an AudioStreamBasicDescription (ASBD) that doesn‚Äôt match the device‚Äôs expected format Stack Overflow+2forum.ikmultimedia.com+2Apple Developer+2Apple Developer+1forum.ikmultimedia.com+1.üõ† Actionable Fixes1. Query & Align ASBD on Both BusesWhen initializing:cppCopyEditAudioStreamBasicDescription desired = {0};desired.mSampleRate = hardwareRate;      // Get from devicedesired.mFormatID = kAudioFormatLinearPCM;desired.mFormatFlags = kAudioFormatFlagIsFloat | kAudioFormatFlagIsPacked;desired.mFramesPerPacket = 1;desired.mChannelsPerFrame = channelCount;desired.mBitsPerChannel = sizeof(float) * 8;desired.mBytesPerFrame = channelCount * sizeof(float);desired.mBytesPerPacket = desired.mBytesPerFrame * desired.mFramesPerPacket;OSStatus err1 = AudioUnitSetProperty(ioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 1, &desired, sizeof(desired));OSStatus err2 = AudioUnitSetProperty(ioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, 0, &desired, sizeof(desired));Use device-native mSampleRate and channelCount. The input scope must match hardware capture; the output scope must match render callback expectations.2. Device Pre-Flight Checks for Proper CleanupIf format negotiation fails, tear down and restart:cppCopyEditif (err1 || err2) {    AudioUnitUninitialize(ioUnit);    AudioComponentInstanceDispose(ioUnit);    // loop back or alert user}This prevents configuration drift and lingering mismatches Apple Developer.3. Verify ASBD Actuals Before UseAfter setting, always query back to confirm:cppCopyEditAudioStreamBasicDescription actual;UInt32 size = sizeof(actual);AudioUnitGetProperty(ioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 1, &actual, &size);// Confirm actual.mSampleRate == desired.mSampleRate etc.If mismatched, adjust shader expectations or buffer sizes.4. Buffer Size AlignmentFormat and buffer size must sync. After audio unit init:cppCopyEditUInt32 maxFrames = 0;UInt32 len = sizeof(maxFrames);AudioUnitGetProperty(ioUnit, kAudioUnitProperty_MaximumFramesPerSlice, kAudioUnitScope_Global, 0, &maxFrames, &len);// Validate maxFrames matches your GPU buffer chunk size.// Adjust your ring/pop/push code if needed.‚úÖ Summary PlanRetrieve hardware sample rate & channel count.Configure ASBD on both input and output buses to match.Check for errors & handle gracefully by teardown/reinit.Confirm actual formats via AudioUnitGetProperty.Align GPU buffer lengths based on MaximumFramesPerSlice.Once ASBD is locked in sync, AudioUnitRender(...) should succeed and your Core Audio ‚Üí GPU pipeline will activate as intended. Want a diff/patch for your bridge code next?SourcesYou said:yesChatGPT said:Here's a targeted, code-first update for your Core Audio bridge to resolve the AudioUnitRender(... ) -> -50 paramErr issue and finally get audio flowing into your GPU pipeline:üéØ Fix: Match Audio Stream Format ExactlyAligning your AudioUnit‚Äôs format on both input and output scopes with the hardware is critical. Here's robust initialization logic:objcCopyEdit// 1. Get hardware sample rate & channel countFloat64 sampleRate = 48000;UInt32 channels = 2;AudioUnitGetProperty(ioUnit,                     kAudioUnitProperty_StreamFormat,                     kAudioUnitScope_Input,                     1, &hwFormat, &propSize);sampleRate = hwFormat.mSampleRate;channels   = hwFormat.mChannelsPerFrame;// 2. Configure desired ASBDAudioStreamBasicDescription desired = {0};desired.mSampleRate       = sampleRate;desired.mFormatID         = kAudioFormatLinearPCM;desired.mFormatFlags      = kAudioFormatFlagIsFloat | kAudioFormatFlagIsPacked;desired.mFramesPerPacket  = 1;desired.mChannelsPerFrame = channels;desired.mBitsPerChannel   = sizeof(float) * 8;desired.mBytesPerFrame    = desired.mChannelsPerFrame * sizeof(float);desired.mBytesPerPacket   = desired.mFramesPerPacket * desired.mBytesPerFrame;// 3. Set input and output scope formatsOSStatus err = AudioUnitSetProperty(ioUnit,    kAudioUnitProperty_StreamFormat,    kAudioUnitScope_Input, 1,    &desired, sizeof(desired));if (err) { /* tear down & retry or log */}err = AudioUnitSetProperty(ioUnit,    kAudioUnitProperty_StreamFormat,    kAudioUnitScope_Output, 0,    &desired, sizeof(desired));if (err) { /* handle failure */ }// 4. Reinitialize Audio UnitAudioUnitUninitialize(ioUnit);AudioUnitInitialize(ioUnit);Why this matters: Apple's Core Audio will throw -50 paramErr on AudioUnitRender if there‚Äôs any mismatch between your declared ASBD and what the hardware actually uses Chromium Git Repositories+4Apple+4Apple Developer+4.üß© Verify the Set FormatAfter setting, query back the format used by Core Audio:objcCopyEditAudioStreamBasicDescription actual;UInt32 size = sizeof(actual);AudioUnitGetProperty(ioUnit,                     kAudioUnitProperty_StreamFormat,                     kAudioUnitScope_Input, 1,                     &actual, &size);assert(actual.mSampleRate == desired.mSampleRate);assert(actual.mChannelsPerFrame == desired.mChannelsPerFrame);If you see any mismatch, adapt your GPU buffer expectations or restart init cleanly.üß™ Configure Buffer Size TooOnce format‚Äôs locked, confirm buffer length aligns with your GPU frame expectations:objcCopyEditUInt32 maxFrames = 0, len = sizeof(maxFrames);AudioUnitGetProperty(ioUnit,    kAudioUnitProperty_MaximumFramesPerSlice,    kAudioUnitScope_Global, 0, &maxFrames, &len);// Use 'maxFrames' to size ring buffers and shader dispatch loopsThat keeps your GPU loop deterministic and avoids misaligned reads/writes.‚úÖ Summary: Why This Stops the -50 ErrorDescribing the wrong format‚Äîeven a sample rate or channel mismatch‚Äîcauses AudioUnitRender to fail immediately .Fixing this will unblock audio flow and push frames into your ring buffer ‚Üí GPU ‚Üí output pipeline.üéØ Next StepsIntegrate this ASBD negotiation into your startAUHALInputOutput() before callbacks are installed.Re-test AudioUnitRender inside your InputRenderCallback ‚Äî it should now return noErr, not -50.Validate live audio appears in the GPU and propagates out via the output callback.Let me know if you'd like an actual diff against your existing bridge code next.SourcesYou said:yesChatGPT said:Thought for 7 secondsBelow is a tailored diff for your CoreAudioBridge implementation, designed to fix the AudioUnitRender ‚Üí -50 paramErr issue by properly negotiating the stream format and buffer configuration. Place this update in your startAUHALInputOutput() (or equivalent) before configuring callbacks:diffCopyEdit@@ -123,6 +123,55 @@ bool CoreAudioBridge::startAUHALInputOutput() {     // After creating and opening ioUnit...+    // ---- BEGIN FIX: Sync Stream Format & Buffer Size ----+    // 1Ô∏è‚É£ Query hardware default format on input scope (bus 1)+    AudioStreamBasicDescription hwASBD = {0};+    UInt32 propSize = sizeof(hwASBD);+    OSStatus err = AudioUnitGetProperty(ioUnit,+        kAudioUnitProperty_StreamFormat,+        kAudioUnitScope_Input, 1,+        &hwASBD, &propSize);+    if (err != noErr) {+        LOG_ERROR("Error querying hardware format: ", err);+        return false;+    }++    // 2Ô∏è‚É£ Build desired ASBD matching hardware+    AudioStreamBasicDescription desired = {};+    desired.mSampleRate       = hwASBD.mSampleRate;+    desired.mFormatID         = kAudioFormatLinearPCM;+    desired.mFormatFlags      = kAudioFormatFlagIsFloat | kAudioFormatFlagIsPacked;+    desired.mChannelsPerFrame = hwASBD.mChannelsPerFrame;+    desired.mFramesPerPacket  = 1;+    desired.mBitsPerChannel   = sizeof(float) * 8;+    desired.mBytesPerFrame    = desired.mChannelsPerFrame * sizeof(float);+    desired.mBytesPerPacket   = desired.mBytesPerFrame * desired.mFramesPerPacket;++    // 3Ô∏è‚É£ Apply format to both input (bus 1) and output (bus 0) scopes+    err = AudioUnitSetProperty(ioUnit,+        kAudioUnitProperty_StreamFormat,+        kAudioUnitScope_Input, 1,+        &desired, sizeof(desired));+    if (err != noErr) {+        LOG_ERROR("Error setting input stream format: ", err);+        return false;+    }+    err = AudioUnitSetProperty(ioUnit,+        kAudioUnitProperty_StreamFormat,+        kAudioUnitScope_Output, 0,+        &desired, sizeof(desired));+    if (err != noErr) {+        LOG_ERROR("Error setting output stream format: ", err);+        return false;+    }++    // 4Ô∏è‚É£ Re-initialize AU after format changes+    AudioUnitUninitialize(ioUnit);+    err = AudioUnitInitialize(ioUnit);+    if (err != noErr) {+        LOG_ERROR("Error re-initializing AudioUnit: ", err);+        return false;+    }++    // 5Ô∏è‚É£ Confirm the actual format matches expectations+    AudioStreamBasicDescription actual = {};+    propSize = sizeof(actual);+    AudioUnitGetProperty(ioUnit,+        kAudioUnitProperty_StreamFormat,+        kAudioUnitScope_Input, 1,+        &actual, &propSize);+    assert(actual.mSampleRate == desired.mSampleRate &&+           actual.mChannelsPerFrame == desired.mChannelsPerFrame);++    // 6Ô∏è‚É£ Retrieve MaximumFramesPerSlice for buffer sizing+    UInt32 maxFrames = 0;+    propSize = sizeof(maxFrames);+    AudioUnitGetProperty(ioUnit,+        kAudioUnitProperty_MaximumFramesPerSlice,+        kAudioUnitScope_Global, 0,+        &maxFrames, &propSize);+    gpuBridge.setMaxFramesPerSlice(maxFrames);+    // ---- END FIX ----‚úÖ Why This WorksParameter Error -50 often arises when the ASBD you set doesn't exactly match the hardware‚Äôs expectations (output scope‚Äôs sample rate not matching hardware) developer.apple.com.Resetting and re-initializing the Audio Unit after setting ensures CoreAudio applies the new format.Confirming the actual format prevents silent mismatches and provides a direct link to your shader and buffer sizing.üéØ Next StepsMerge this snippet into your bridge initializer.Retry AudioUnitRender() in the Input callback ‚Äî expect noErr.Confirm audio frames flow into your GPU ring buffer without failure.Ensure output callback also receives correct floats from downloadOutputFromGPU() and forwards them on.Once AudioUnitRender() stops returning -50, your Core Audio ‚Üí GPU pipeline will finally be live. Tell me when it works or if you'd like help integrating this into your unit tests!
