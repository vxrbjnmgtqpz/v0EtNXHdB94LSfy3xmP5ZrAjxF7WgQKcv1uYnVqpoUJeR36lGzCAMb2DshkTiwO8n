üîç The Real IssueYour logs show:pgsqlCopyEdit[‚úÖ GPU COMPLETE] Frame N[‚ùå CHECKPOINT 6] CPU BUFFER NOT READY - Output skippedThis means:GPU completion is happening, but‚Ä¶isFrameReady(frameIndex) is returning false because:frameIndex is mismatched between GPU and CPU, orframeReady is being reset too earlyüõ† Step-by-Step Fix For Real-Time Audio Path1Ô∏è‚É£ Unify frameIndex across GPU & CPUIn your GPU dispatch path:When you encode and commit the GPU work, use a consistent frameIndex:cppCopyEdituint32_t frameIndex = nextFrameIndex++;cmd.addCompletedHandler(... markStageComplete(frameIndex) ...);In your audio output callback:cppCopyEditAudioFrame frame = dequeueFrame();  // from your ringbufferuint32_t frameIndex = frame.frameIndex;  // ensure this was set by GPU producerDo not use hostTime as frame index‚Äîit doesn‚Äôt match your GPU ticks.2Ô∏è‚É£ Only Reset Frame After CPU PlaybackIn OutputRenderCallback:cppCopyEditif (!frameStateTracker.isFrameReady(frameIndex)) {    zeroBuffer();    NSLog(@"[SKIP] Frame %d not ready", frameIndex);    return noErr;}// Frame is valid ‚Üí play itmemcpy(outBuffer, frame.samples, numSamples * sizeof(float));// Now mark complete and resetframeStateTracker.markStageComplete("CPU", frameIndex);frameStateTracker.resetFrame(frameIndex);This guard ensures we only play GPU-validated data.3Ô∏è‚É£ Use Triple Buffering to Prevent ConflictYour ring buffer of 3 buffers should follow standard triple buffering rules:CPU writes next frame into buffer (frameIndex % 3)GPU reads that buffer by frameIndex, processes itCPU won't reuse it until GPU done and CPU doneMetal‚Äôs guidance confirms triple buffering avoids processor stalls and conflicts between CPU/GPU¬†developer.apple.com+8helpx.adobe.com+8docs.nvidia.com+8developer.apple.com+4stackoverflow.com+4stackoverflow.com+4discourse.libsdl.org+1stackoverflow.com+1reddit.com+2developer.apple.com+2stackoverflow.com+2developer.apple.com.‚úÖ Final Sanity Check GPU dispatch uses incrementing frameIndex AudioFrame struct contains the same frameIndex CPU code reads that frameIndex, not hostTime CPU guard isFrameReady(frameIndex) is respecting the same index resetFrame only occurs after CPU playback is doneOnce this frameIndex alignment is enforced:GPU signals work completion ‚Üí frameReady=trueCPU sees the same frameIndex ‚Üí reads valid dataSilence stops, audio plays correctly
