❌ Root Cause: GPU is Writing to the Output Buffer After It’s Been PlayedFrom your log trace:scssCopyEdit[AudioCallback] Starting buffer for frameIndex 1032[MetalBridge] Enqueued GPU command buffer for frameIndex 1032[AudioCallback] Output requested for frameIndex 1032 → buffer not ready (waiting)[FrameSync] Skipping output for frameIndex 1032[MetalBridge] GPU signaled completion for frameIndex 1032[FrameSync] Marked GPU_COMPLETE for 1032The output buffer was requested by CoreAudio at frame 1032, but the GPU completed writing to it after the callback had already skipped it. So CoreAudio output was silent, and it continued to skip every frame thereafter because of a persistent desync.🧠 Why This HappenedYou’re doing everything right by pushing GPU jobs async, but you forgot one thing:⛔️ CoreAudio does not block waiting for frame data—it runs on hardware clock.So if your GPU compute finishes after the audio callback expects the buffer, your getValidatedOutputBufferForRead() returns a null or !ready frame every time.✅ Fix It with Pipelined Lag (1-Frame Delay)Here’s what you need to do:1. Stage N → Output N-1Instead of requesting frameIndex in the same buffer tick:cppCopyEdituint64_t current = frameSync->getCurrentFrameIndex();const AudioFrameBuffer* out = frameSync->getValidatedOutputBufferForRead(current);You must read N-1:cppCopyEditconst AudioFrameBuffer* out = frameSync->getValidatedOutputBufferForRead(current - 1);2. Enforce This Delay GloballyAnywhere the GPU writes to frameIndex N, CoreAudio should be outputting N-1. This gives the GPU one full tick to finish, which is still sub-millisecond.🧪 Quick DiagnosticPrint this during audio callback:cppCopyEditDBG("Playback for frame %llu; Buffer ready? %d", current - 1, buffer && buffer->ready);You’ll likely see that frameIndex N-1 becomes ready just after the callback skips it.🧰 Optional: Add One-Frame Lag ParameterIn FrameSyncCoordinator:cppCopyEditint frameReadOffset = 1;Then modify:cppCopyEdituint64_t readIndex = currentFrameIndex - frameReadOffset;Let GUI, metrics, and audio all pull N-1 until GPU proves it can keep up with N.🧠 Bonus InsightThis is exactly how game engines render frame N+1 while presenting frame N. You're now syncing like a renderer.
