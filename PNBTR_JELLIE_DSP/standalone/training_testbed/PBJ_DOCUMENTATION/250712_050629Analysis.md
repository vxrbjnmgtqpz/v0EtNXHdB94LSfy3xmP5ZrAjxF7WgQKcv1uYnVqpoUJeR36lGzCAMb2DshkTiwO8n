Youâ€™re still getting:pgsqlCopyEdit[âœ… GPU COMPLETE] Frame N[âŒ CHECKPOINT 6] CPU BUFFER NOT READY - Output skippedSo hereâ€™s what that really means:ğŸ§¨ Whatâ€™s Happening Nowâœ… GPU is completing â€” addCompletedHandler is firingâŒ But OutputRenderCallback still doesnâ€™t think the frame is readyğŸ§  Therefore: frameStateTracker.valid is never set to true, or it gets reset before CPU sees itğŸ”¬ Root Scenarios to CheckğŸ” 1. resetFrame(frameIndex) is being called too earlyIf you call resetFrame() right after markStageComplete("GPU"), you zero out readiness before CPU ever gets to itFix:Only call resetFrame(frameIndex) after CPU finishes audio output, not from GPU handler.ğŸ“¥ 2. markStageComplete("CPU") is called before isFrameReady() checkFix:The sequence in OutputRenderCallback must be:cppCopyEditif (!frameStateTracker.isFrameReady(frameIndex)) {    return silence;}// â†’ here is safe to use audioplay(buffer[frameIndex]);// THEN:frameStateTracker.markStageComplete("CPU", frameIndex);frameStateTracker.resetFrame(frameIndex);ğŸ§  3. frameIndex mismatchLog this in both places:cppCopyEditNSLog(@"[RENDER] frameIndex = %d", frameIndex);NSLog(@"[GPU]     frameIndex = %d", frameIndex);If theyâ€™re not exactly the same, your CPU is reading the wrong frame.ğŸ” 4. Completion handler is racing the audio threadIf addCompletedHandler fires after OutputRenderCallback already tried to read that frame, youâ€™ll always skip one.Fix (safe fallback):In CPU thread:cppCopyEditwhile (!frameStateTracker.isFrameReady(frameIndex)) {    __asm__ __volatile__ ("" ::: "memory");}(This is technically busy-waiting, but with triple buffering and a ready flag, it stalls only for microseconds.)
