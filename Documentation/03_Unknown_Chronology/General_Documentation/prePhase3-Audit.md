Why the TOASTer App’s Connection, Transport, and Note Passing Aren’t Working

TL;DR: The current TOASTer app (a JUCE/C++ test application for the TOAST protocol) is running but not truly functioning because its networking and message-handling are incomplete. It says “Connected” in the UI, but that status is likely a false positive – the underlying TCP connection either isn’t fully established or isn’t communicating properly. As a result, transport controls (start/stop sync) and MIDI note messages aren’t being transmitted or handled between the two instances. Below, we break down the issues in each area and why they’re happening, given the pre–Phase 3 state of the project.

1. Connection Status vs. Actual Connectivity
	•	False “Connected” Indicator: The app’s UI shows a “Connected” status even though the two peers are not truly communicating. This likely happens because the code simply flags the connection as successful when a connect function is called, without a complete handshake or data exchange to confirm. In other words, the TOASTer app might be marking itself connected as soon as a socket attempt is made (or immediately upon launching in a test mode) instead of waiting for a real peer acknowledgment. This is a common cause of false positives in network apps.
	•	Server/Client Role Misconfiguration: It’s possible each TOASTer instance is not properly distinguishing server vs. client roles. For a peer-to-peer TCP connection, one side must listen (server) and the other must initiate (client). If this isn’t set up correctly, both apps could either be waiting for a connection that never comes, or each might be connecting to the wrong place (for example, each connecting to its own localhost instead of the other’s address). Such a scenario would make the UI think “I’m connected” (perhaps each app connected to itself or a dummy socket) when in reality the two apps aren’t talking to each other at all.
	•	Legacy Bassoon.js Networking: Since the JAM framework (the planned Bassoon.js fork) hasn’t been integrated yet, the TOASTer app may still be using placeholders or legacy connection logic. The roadmap notes that as of now the system is “currently running TCP – ready for UDP transition” and that Bassoon’s old HTTP/event-stream layers haven’t been removed yet. This means the app might still be following Bassoon’s original networking model (possibly involving an event stream or a central server) which isn’t actually set up in this testing scenario. If TOASTer is trying to use a Bassoon-style connection (e.g. expecting a server or some signaling that isn’t there), it could erroneously report a connection without a functional data channel. In short, the network stack is in a half-implemented state – the code to truly establish peer-to-peer communication is likely incomplete, so the “Connected” light is on but the wires aren’t properly connected behind the scenes.

2. Transport Sync (Start/Stop) Not Working
	•	No Remote Trigger Implementation: The transport control (e.g. pressing “Play/Stop” in one app to control the other) isn’t functioning because the messaging for it is not fully implemented. In a working setup, one app would send a “transport start/stop” message to the other, which would then respond by starting or stopping its playback almost instantly. Currently, that response isn’t happening. This could be because the TOASTer app isn’t actually sending out the transport command over the network at all (due to the connection issues above or missing code), or the other side isn’t listening/handling that command.
	•	Missing Message Handling on Receive: Even if a transport message is sent, the receiving side might not know what to do with it. Since this is a pre-Phase 3 audit, many control messages might still be unhooked. For example, the code might have a TODO or placeholder for “onReceiveTransportCommand” that currently does nothing. If the app’s foundation was adapted from Bassoon or another source, it’s possible that the function to handle an incoming “start” signal wasn’t written yet – so the message gets ignored. Thus, you press “Play” on App A, it thinks it sent a command, App B might even receive something, but without a proper handler to sync the transport, nothing happens on B.
	•	Synchronization Not Established: Another aspect is that true transport sync requires both peers to share timing information (e.g. BPM, position, clock pulses). It’s likely that no timing/clock sync was implemented yet. The roadmap’s current state focuses on basic TCP streaming as a control group, not on sync logic. So even if a “start” message went through, the apps don’t have a common clock or position reference, causing one side to simply not react. In summary, transport control is effectively a stub right now – the UI control exists, but the network message either isn’t delivered or isn’t acted upon, so the remote transport never engages.

3. MIDI Note Passing Not Functioning
	•	Events Not Being Sent Across: The core idea of MIDI note passing is that when you play a note on one system, the MIDI event is serialized (likely as JSON or a compact JMID message) and transmitted to the other system, where it’s then turned into sound or MIDI-out. At the moment, those note events aren’t making it across. Given the incomplete networking, the sending side might not actually be transmitting the MIDI data. For example, the TOASTer app might capture a local MIDI input (or a test note from its UI) but never calls the send function – possibly because the connection isn’t truly open or because the send function is unimplemented. If Bassoon’s original architecture relied on a different mechanism (like a web service or event polling) that isn’t present, the notes would just stay local.
	•	Events Not Received or Processed: Even if the note data is sent, the other side may not be processing it. There needs to be code that says “on incoming MIDI JSON message, reconstruct it as a MIDI event and feed it to the synth or MIDI device.” It sounds like this part is missing or broken. The receiving TOASTer app possibly gets the data (or would if the network worked) but doesn’t route it anywhere – e.g. not triggering any sound generator. Since “we haven’t hooked anything else up to it yet,” it’s likely there’s no synth or MIDI-out configured in the app. So even in the best case (if the note did arrive), you wouldn’t hear or see much, because the app doesn’t yet know how to play a note externally. Essentially, the MIDI forwarding pipeline is incomplete: the chain of capture → serialize → send → receive → deserialize → output isn’t fully wired end-to-end.
	•	Ultra Low Latency Goal Not Yet Realized: The user’s expectation is “ultra low latency” reaction for remote notes – but that’s contingent on the new optimized protocol which isn’t in place yet. Right now everything is over basic TCP and without the GPU-accelerated JSON pipeline, so even if it did work, latency would be higher. The roadmap even labels the current version as a “control group” running on plain TCP. This suggests that the low-latency optimizations (multicast JSONL, etc.) are planned but not active yet. So, the note passing is not only broken functionally, it’s also not tuned for performance at this stage. The “ultra-low latency” will come after the protocol is improved; pre-Phase 3, the focus was on getting something working at all – which, as we see, still needs fixing.

Conclusion: Underlying Causes

In summary, the TOASTer app isn’t working yet because it’s essentially an early prototype with unfinished networking logic. The “Connected” status is likely cosmetic – the two apps aren’t truly connected due to either a misconfigured TCP handshake or reliance on a not-yet-implemented Bassoon signaling mechanism. With no real data link, transport commands and MIDI notes never get delivered or handled. Even where parts of the code exist, they appear to be placeholders (pending the Phase 3 overhaul where Bassoon.js will be properly integrated and UDP networking introduced).

Before Phase 3 begins, an audit should correct these issues in Phase 2’s deliverables:
	•	Ensure the connection handshake is real – e.g. one app acts as host, the other as client, and they truly establish a socket link (over TCP for now) with proper acknowledgment. The UI should only show “Connected” when a two-way channel is confirmed.
	•	Implement or fix the message-sending routines for transport and notes. The app needs to actually send a “start” command or MIDI JSON packet across the socket when those events occur.
	•	Implement the receive handlers on the opposite side. When data arrives, the app should interpret a transport message by triggering its local play/stop, and interpret MIDI messages by playing a note (perhaps using a simple built-in synth or forwarding to a MIDI Out port).

Given that the TOASTer GUI “builds and runs successfully” but is still using the old TCP paradigm, addressing the above will turn the running app into a functioning app. These fixes will likely involve removing remaining Bassoon/HTTP stubs, solidifying the socket code, and hooking up event callbacks. Once that’s done, the foundation will be laid for the upcoming Phase 3 (the Bassoon.js fork and UDP implementation), at which point true ultra-low-latency performance can be achieved.