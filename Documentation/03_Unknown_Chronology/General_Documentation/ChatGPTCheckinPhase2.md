
# MIDIp2p & MIDILink Project Status

The **JMID framework** appears partially implemented: a JSON schema for MIDI messages may be defined, but it lacks code-side validation.  For example, libraries like *midi-json-parser* can convert a MIDI file to a JSON object and back into binary, demonstrating that a JSON-based representation is feasible. However, any JMID schema must be rigorously checked in code to ensure all messages conform to the expected format.  At present there is no evidence (in documentation or commits) that such schema validation is in place.  Without validation, malformed messages or version mismatches could slip through.

Similarly, key protocol mechanisms seem unimplemented.  The **MIDILink app**’s roadmap mentions a custom “TOAST” transport for sending MIDI over a network, but no public code or docs show TOAST actually implemented.  In practice, sending MIDI over IP-like networks is commonly done via RTP-MIDI (AppleMIDI) – a standard that wraps MIDI in RTP packets.  If TOAST is still only a design, the app cannot actually route live MIDI notes over the network.  Likewise, a **ClockDriftArbiter** (to correct timing drift between devices) is listed in the design but not found in code; missing this would leave note timing unstable.  In short, the MIDILink app currently has only basic MIDI linkage; features like note-passing over TOAST and drift correction appear still to be future work rather than completed functionality.

Planned architecture items should be reviewed: the JMID schema may exist on paper, but without implemented validators or parsers it is “defined but not enforced.”  Likewise, the TOAST transport may be specified, but commits show no working transport layer (the app thus can’t currently send raw MIDI data end-to-end).  Other roadmap items (e.g. UI, packaging, MIDI port mapping) may exist in code or be pending.  Critically, **version negotiation and fallback** has likely been overlooked.  The official MIDI 2.0 spec uses the Universal MIDI Packet (UMP) but explicitly preserves MIDI 1.0 compatibility.  MIDI Capability Inquiry (MIDI-CI) allows devices to negotiate MIDI 1.0 vs. 2.0 protocols and fall back as needed.  There is no sign that MIDILink implements MIDI-CI or any version‐selection mechanism.  Without this, newer MIDI‐2 messages carried via JMID would fail with older gear.  Likewise, the open JSON-based “MIDI RTC” schema approach has been praised for *not breaking* existing MIDI 1.0 devices, but it still requires deliberate support for compatibility.  In summary, backward‐compatibility, negotiation and fallback – cornerstones of any robust MIDI-2 design – are not yet addressed in the codebase.

* **Key features implemented:** Basic JSON-based message definitions exist; a rudimentary link between devices is in place. Some groundwork (e.g. defining JMID format) is laid out.
* **Missing or incomplete items:** JSON schema validation/tests, TOAST transport code, real-time MIDI note transmission, clock drift correction, and MIDI-CI–style negotiation are not yet in code.
* **Design steps overlooked:** Proper handling of MIDI 1.0/2.0 interop and version selection (per MIDI-CI), as well as backward compatibility testing. Also note that any open MIDI/JSON schema should be integrated carefully so as *not* to break older devices.

**Conclusion:** In its current state, MIDILink has some of the **infrastructure** in place (JSON message format, basic network link) but lacks several **essential components** planned for Phase 2. Without implementing the TOAST transport, clock-drift arbitration, and protocol negotiation, the app cannot fully meet its design goals.  Similarly, the framework needs schema validation and compatibility measures.  Until those key elements are completed and tested, it would be premature to move on to Phase 2. The project should first fill these gaps (using established best practices like RTP‐MIDI networking and MIDI‐CI negotiation) to ensure a solid, interoperable foundation.

**Sources:** The MIDI 2.0 spec notes that UMP carries both MIDI 1.0 and 2.0 messages and prioritizes backward compatibility. JSON MIDI converters exist in the ecosystem, and open JSON MIDI schemas (like Open MIDI RTC) emphasize compatibility. Network MIDI transport examples (e.g. RTP-MIDI) demonstrate one way to send MIDI over IP. MIDI-CI protocols allow device negotiation between MIDI 1.0/2.0 modes. These concepts underline the missing pieces in the current implementation.
